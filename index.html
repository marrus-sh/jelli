<!DOCTYPE html>
<html>
    <head>
        <title>Jelli : A Game Engine</title>
        <meta charset="utf-8">
        <meta name="viewport" content="user-scalable=no,width=device-width">
        <link rel="icon" href="icon.png">
        <!--  `style.css` is necessary for styling the controls on mobile in this stage of development  -->
        <link rel="stylesheet" href="style.css">
        <script type="text/javascript" src="jelli.js"></script>
        <script type="text/javascript">
            /*
                This creates the game on load, using this document as its source.
                It will automatically assign itself to `document.game`.
            */
            window.addEventListener("load", function () {new Game(document);}, false);
        </script>
        <script type="text/plain" class="init">

            >>  Area 0 is the splash screen (see below)

            loadArea (0)

        </script>
        <script type="text/plain" class="step">

            >>  Step code would go here

        </script>
    </head>
    <body hidden style="display: none;">
        <h1>Jelli : A Game Engine</h1>
        <p>
            Any content you place in here remains hidden unless it is assigned the proper class for handling by the script.
            By editing this file, you can program your game.
        </p>
        <p>
            Be sure to keep the <code>hidden</code> attribute on the <code>&lt;body&gt;</code> element, and to load the jelli script in the <code>&lt;head&gt;</code>.
            <code>&lt;meta name="viewport" content="user-scalable=no,width=device-width"&gt;</code> is also helpful.
        </p>
        <section>
            <h2>Game setup</h2>
            <p>
                Certain attributes on the &lt;html&gt; element can be used to configure game settings.
                The <code>data-vars</code> attribute declares global JelliScript variables which can be accessed from any JelliScript code.
            </p>
            <p>
                Sometimes the game itself needs scripting which cannot be achieved at a lower level.
                This can be accomplished through two scripts, which should appear in the &lt;head&gt;.
                The first, of class <code>init</code>, specifies the initialization code, which is run during game setup.
                The second, of class <code>step</code>, specifies the code to run each time the game's logic is processed.
                These scripts should have type <code>text/plain</code> and be written in JelliScript.
            </p>
        </section>
        <section>
            <h2>GUI Elements</h2>
            <p>
                These elements are used to render the game system itself, rather than things within the game.
                They are not drawn to the canvas.
                The first <code>&lt;img&gt;</code> elements with the given classes will be chosen.
            </p>
            <section>
                <h3>The elements:</h3>
                <img class="gui-border" alt="Border" src="gui/cnvs-border.png"
                     data-sprite-width="8"
                     data-sprite-height="8"
                     data-system-background="#4f4f4f"
                     data-screen-background="#000000"
                     >
                <!--  Right now this doesn't do anything: Control stuff is still in development, and currently is styled using `style.css` :(  -->
                <img class="gui-buttons" alt="Buttons" src="gui/ctrl.png"
                     data-sprite-width="16"
                     data-sprite-height="16"
                     data-button-width="24"
                     data-button-height="24"
                     >
            </section>
        </section>
        <section>
            <h2>Screens</h2>
            <p>
                The <code>&lt;canvas&gt;</code> element creates a screen where the game is actually drawn.
                These elements should be listed in order, from back to front.
                The <code>id</code> of these elements <strong>must</strong> be specified (and unique)&mdash;this is used as an identifier within the game's script.
            </p>
            <p>
                The <code>data-type</code> attribute lets the game know how often the canvas should be cleared.
                <code>area</code> canvases are only cleared on area change, and are a good place to draw tiles.
                <code>animation</code> canvases, on the other hand, are cleared every frame, and are intended for animations.
                Canvases without this attribute must be cleared manually.
            </p>
            <section>
                <h3>The canvases:</h3>
                <canvas id="background" data-type="area" width="256" height="160">Map tiles go here.</canvas>
                <canvas id="mainground" data-type="animation" width="256" height="160">Characters and particles go here.</canvas>
                <canvas id="foreground" data-type="area" width="256" height="160">Structures go here.</canvas>
                <canvas id="textground" width="256" height="160">Dialogue and the like goes here.</canvas>
                <canvas id="menuground" width="256" height="160">HUDs and pause menus go here.</canvas>
            </section>
        </section>
        <section>
            <h2>Sprite sheets</h2>
            <p>
                These elements contain the sprites used throughout the game.
                Their type is identified via their class: <code>letters</code> identifies an alphabet, <code>tileset</code> represents a tileset, and <code>sheet</code> represents any other spritesheet, such as one for use with characters.
                The <code>id</code> of these elements <strong>must</strong> be specified (and unique)&mdash;this is used as an identifier within the game's script.
            </p>
            <p>
                <code>tileset</code> sprite sheets <strong>must</strong> be provided with a <code>data-collisions</code> attribute, whose value is Base64-encoded binary collision data.
                This data should be a sequence of 4-bit bytes, one for each tile in the set, indicating which parts of the tile prevent objects from passing through.
                The least significant bit notes the top-left corner, the next the top-right, then the bottom-left, and the most significant bit indicates the bottom-right.
                Thus, a tile which has been assigned the bit <code>0x7</code> = <code>0111</code> (big endian) only allows objects through its bottom-right corner, while the bit <code>0x8</code> = <code>1000</code> permits the opposite.
            </p>
            <p>
                <code>letters</code> sprite sheets may optionally have any number of <code>data-palette-*</code> attributes assigned, these specify options for text colour.
            </p>
            <section>
                <h3>The letters:</h3>
                <img id="letters" class="letters" alt="Letters" src="letters/letters.png"
                     data-sprite-width="3"
                     data-sprite-height="5"
                     data-linefeed="&#x0A;"
                     data-palette-black="#0c0c0c"
                     data-palette-red="#e83f2c"
                     data-palette-sea="#31b9db"
                     >
            </section>
            <section>
                <h3>The tilesets:</h3>
                <img id="tiles" class="tileset" alt="Tiles" src="tilesets/tiles.png"
                     data-sprite-width="16"
                     data-sprite-height="16"
                     data-collisions="///APw=="
                     >
            </section>
            <section>
                <h3>Other sheets:</h3>
                <img id="characters" class="sheet" alt="Jelly" src="sheets/characters.png"
                     data-sprite-width="16"
                     data-sprite-height="16"
                     >
            </section>
        </section>
        <section>
            <h2>Sprites</h2>
            <p>
                Game characters are rendered using collections of sprites, which are given the class <code>sprites</code> and contain sprites of class <code>sprite</code>.
                The <code>id</code>s of sprite collections <strong>must</strong> be specified (and unique)&mdash;they are used as an identifier within the game's script.
                Additionally, the <code>data-sheet</code> attribute needs to be defined:
                It specifies which <code>sheet</code> to draw the sprites from.
            </p>
            <p>
                The <code>data-box-x</code>, <code>data-box-y</code>, <code>data-box-width</code>, and <code>data-box-height</code> attributes set the center and dimensions of the sprite bounding box (for collision checking).
                If not set, the box will fill the entire sprite.
            </p>
            <p>
                The sprites themselves take a couple of attributes:
                <code>title</code> names the sprite&mdash;these need to be unique within a given sprite collection but not necessarily across the document.
                It essentially functions by setting up a character variable with the value of the sprite's number, and you can always just use the number instead.
                <code>data-index</code> (required) specifies the starting index for the sprite, and <code>data-length</code> specifies the length of the animation (this defaults to 1).
            </p>
            <section>
                <h3>Sprite collections:</h3>
                <div id="jelly" class="sprites"
                     data-sheet="characters"
                     data-box-x="8"
                     data-box-y="8"
                     data-box-width="10"
                     data-box-height="10">
                    <span class="sprite"
                          title="lf"
                          data-index="0"
                          data-length="2"
                          ></span>
                    <span class="sprite"
                          title="rt"
                          data-index="2"
                          data-length="2"
                          ></span>
                </div>
            </section>
        </section>
        <section>
            <h2>Characters</h2>
            <p>
                Characters are used to insert any interactive element&mdash;including NPCs and player characters, but also potentially other elements, like doors&mdash;into the game.
                They have the class <code>character</code>, and should a couple of scripts.
                The <code>data-vars</code> element is used to declare character variables for use later in code; these are initialized to 0.
                The <code>data-sprites</code> element tells which sprite collection to use with the character.
            </p>
            <p>
                Characters generally need scripting.
                This is accomplished through two scripts, which should be placed inside the character.
                The first, of class <code>init</code>, specifies the initialization code, which is run when the area is loaded.
                The second, of class <code>step</code>, specifies the code to run each time the game's logic is processed.
                These scripts should have type <code>text/plain</code> and be written in JelliScript.
            </p>
            <p>
                Characters are destroyed when an area is unloaded, and the values of their variables are not stored.
            </p>
            <section>
                <h3>Some characters:</h3>
                <div id="pointer" class="character"
                     data-sprites="jelly"
                     data-vars="timer"
                     >
                </div>
                <div id="player" class="character"
                     data-sprites="jelly"
                     data-vars="timer"
                     >
                    <script type="text/plain" class="init">
                            x.set (16)
                            y.set (80)
                            dir.set (rt)
                    </script>
                    <script type="text/plain" class="step">

                            >>  This controls jelly movement:

                            (game.key_up) ?
                                (game.key_down) ?
                                    (game.key_left) ?
                                        (game.key_right) ?
                                            targetBy (0, 0)
                                        :
                                            targetBy (-1, 0)
                                        ;
                                    :
                                        (game.key_right) ?
                                            targetBy (1, 0)
                                        :
                                            targetBy (0, 0)
                                        ;
                                    ;
                                :
                                    (game.key_left) ?
                                        (game.key_right) ?
                                            targetBy (0, -1)
                                        :
                                            targetBy (-1, -1)
                                        ;
                                    :
                                        (game.key_right) ?
                                            targetBy (1, -1)
                                        :
                                            targetBy (0, -1)
                                        ;
                                    ;
                                ;
                            :
                                (game.key_down) ?
                                    (game.key_left) ?
                                        (game.key_right) ?
                                            targetBy (0, 1)
                                        :
                                            targetBy (-1, 1)
                                        ;
                                    :
                                        (game.key_right) ?
                                            targetBy (1, 1)
                                        :
                                            targetBy (0, 1)
                                        ;
                                    ;
                                :
                                    (game.key_left) ?
                                        (game.key_right) ?
                                            targetBy (0, 0)
                                        :
                                            targetBy (-1, 0)
                                        ;
                                    :
                                        (game.key_right) ?
                                            targetBy (1, 0)
                                        :
                                            targetBy (0, 0)
                                        ;
                                    ;
                                ;
                            ;

                            >>  This controls the direction the jelly is facing:

                            (game.key_left) ?
                                -(game.key_right) dir.set (lf)
                            :
                                (game.key_right) dir.set (rt)
                            ;

                            >>  This makes the jelly fall a little regardless:

                            targetBy (0, .1)

                            >>  This increments the timer if an arrow key is pressed:

                            (game.key_up)(game.key_down)(game.key_left)(game.key_right) ?
                                timer.mod_increment (15)
                                -(timer) frame.mod_increment (2)
                            ;

                    </script>
                </div>
            </section>
        </section>
        <section>
            <h2>Areas</h2>
            <p>
                Areas are used to generate a static background and/or foreground on which a section of the game takes place.
                Areas are given the class <code>area</code>, and should contain maps of the class <code>map</code>.
                Areas are referred to by index:
                The first area you define will have index 0, and the numbers will increase from there.
                (It makes sense to have area 0 be a splash screen).
            </p>
            <p>
                Maps tell the game how to render tiles on the screen.
                They are Base64-encoded strings, which should decode into 8-bit binary data.
                Each byte provides the index of the appropriate tile for that square in the map grid.
                The <code>data-tileset</code> attribute identifies the tileset from which to draw the tile, and the <code>data-mapwidth</code> attribute should tell how many tiles the map is wide.
                The <code>data-canvas</code> attribute should identify the canvas on which the map should be drawn.
            </p>
            <p>
                Characters can be loaded by referencing their <code>id</code>s in the <code>data-characters</code> attribute, or by passing a string to the <code>loadCharacters</code> function.
                This creates a new JelliScript object at <code>characters.character_id</code>.
                Characters can be deleted with the <code>characters.delete</code> function.
            </p>
            <section>
                <h3>Some areas:</h3>
                <div class="area" title="Splash screen"
                     data-vars="title_timer"
                     >
                    I have used this area to demonstrate programmatic character loading and managing.
                    <span class="map"
                          data-tileset="tiles"
                          data-mapwidth="16"
                          data-screen="background"
                          >AAEAAQABAAEAAQABAAEAAQIDAgMCAwIDAgMCAwIDAgMAAQABAAEAAQABAAEAAQABAgMCAwIDAgMCAwIDAgMCAwABAAEAAQABAAEAAQABAAECAwIDAgMCAwIDAgMCAwIDAAEAAQABAAEAAQABAAEAAQIDAgMCAwIDAgMCAwIDAgMAAQABAAEAAQABAAEAAQABAgMCAwIDAgMCAwIDAgMCAw==</span>
                    <script type="text/plain" class="init">
                        characters.pointer.load
                        characters.pointer.x.set (88)
                        characters.pointer.y.set (120)
                        characters.pointer.dir.set (characters.pointer.lf)
                        game.texts.title.create ("textground", "letters", "Jelli Game Engine -- Demo")
                        game.texts.title.x.set (78)
                        game.texts.title.y.set (60)
                        game.texts.title.color.set ("sea")
                        game.texts.menu1.create ("textground", "letters", "Use arrow keys to move")
                        game.texts.menu1.x.set (96)
                        game.texts.menu1.y.set (120)
                        game.texts.menu1.color.set ("red")
                        game.texts.menu1.fill
                        game.texts.menu2.create ("textground", "letters", "Press X to begin")
                        game.texts.menu2.x.set (96)
                        game.texts.menu2.y.set (136)
                        game.texts.menu2.color.set ("black")
                        game.texts.menu2.fill
                    </script>
                    <script type="text/plain" class="step">
                        -(title_timer) game.texts.title.advance
                        title_timer.mod_increment (30)
                        (game.key_down) ?
                            characters.pointer.y.set (136)
                            game.texts.menu1.clear
                            game.texts.menu1.color.set ("black")
                            game.texts.menu1.fill
                            game.texts.menu2.clear
                            game.texts.menu2.color.set ("red")
                            game.texts.menu2.fill
                        ;
                        (game.key_up) ?
                            characters.pointer.y.set (120)
                            game.texts.menu1.clear
                            game.texts.menu1.color.set ("red")
                            game.texts.menu1.fill
                            game.texts.menu2.clear
                            game.texts.menu2.color.set ("black")
                            game.texts.menu2.fill
                        ;
                        (game.key_action) ?
                            characters.pointer.dir.set (characters.pointer.rt)
                            game.texts.title.delete
                            game.texts.menu1.delete
                            game.texts.menu2.delete
                            game.clearScreen ("textground")
                            game.loadArea (1)
                        :
                            characters.pointer.dir.set (characters.pointer.lf)
                        ;
                        characters.pointer.timer.mod_increment (10)
                        -(characters.pointer.timer) characters.pointer.frame.mod_increment (2)
                    </script>
                </div>
                <div class="area" title="The Sea"
                     data-characters="player"
                     data-vars="scroll_left scroll_right tx map0x map1x"
                     >
                    It is often way easier to define character code in their own init and step functions, however, as demonstrated here.
                    Then you can load the characters with the <code>data-characters</code> attribute.
                    <span class="map"
                          data-tileset="tiles"
                          data-mapwidth="16"
                          data-screen="background"
                          >BwcHBwcHBwcHBwcHBwcHBwYGBgYGBgYGBgYGBgYGBgYFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUBBQUFBQUFBQUFBQUFBQUFBAQEBAQEBAQEBAQEBAQEBA==</span>
                    <span class="map"
                          data-tileset="tiles"
                          data-mapwidth="16"
                          data-dx="256"
                          data-screen="background"
                          >BwcHBwcHBwcHBwcHBwcHBwYGBgYGBgYGBgYGBgYGBgYFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUBBQUFBQUFBQUFBQUFBQUFBAQEBAQEBAQEBAQEBAQEBA==</span>
                    <script type="text/plain" class="init">
                        map0x.set (0)
                        map1x.set (256)
                    </script>
                    <script type="text/plain" class="step">
                        tx.set (characters.player.x)
                        tx.increment (x)
                        (tx < 8) scroll_left.set (1)
                        (tx > 248) scroll_right.set (1)
                        (scroll_left) x.increment (1)
                        (scroll_right) x.increment (-1)
                        tx.set (-x)
                        (tx < map0x) ?
                            map0x.increment (-256)
                            map1x.increment (-256)
                            setMapOffset (0, map0x)
                            setMapOffset (1, map1x)
                        ;
                        -(tx < map1x) ?
                            map0x.increment (256)
                            map1x.increment (256)
                            setMapOffset (0, map0x)
                            setMapOffset (1, map1x)
                        ;
                        scroll_left.set (0)
                        scroll_right.set (0)
                    </script>
                </div>
            </section>
        </section>

        <!--  Until control mechanisms are improved, just leave these divs as they are at the bottom of the page and pretend they don't exist XP  -->
        <div id="jo-ctls-lf">
            <!--  Left Controls  -->
            <div id="jo-ctlr-l1">
                <div id="jo-ctrl-selc" title="Select"></div>
                <div id="jo-ctrl-strt" title="Start"></div>
            </div>
            <div id="jo-ctlr-l2">
                <div id="jo-ctrl-look" title="Look"></div>
                <div id="jo-ctrl-menu" title="Menu"></div>
            </div>
            <div id="jo-ctlr-l3">
                <div id="jo-ctrl-exit" title="Exit"></div>
                <div id="jo-ctrl-actn" title="Action"></div>
            </div>
        </div>
        <div id="jo-ctls-rt">
            <!--  Right Controls  -->
            <div id="jo-ctlr-r1">
                <div id="jo-ctrl-uprw" title="Up Arrow"></div>
            </div>
            <div id="jo-ctlr-r2">
                <div id="jo-ctrl-lfrw" title="Left Arrow"></div>
                <div id="jo-ctrl-rtrw" title="Right Arrow"></div>
            </div>
            <div id="jo-ctlr-r3">
                <div id="jo-ctrl-dnrw" title="Down Arrow"></div>
            </div>
        </div>
    </body>
</html>
