<!DOCTYPE html>
<html data-vars="poke_active poke2_active poke_x poke_y">
    <head>
        <title>Jelli : A Game Engine</title>
        <meta charset="utf-8">
        <meta name="viewport" content="user-scalable=no,width=device-width">
        <link rel="icon" href="icon.png">
        <script type="text/javascript" src="jelli.js"></script>
        <script type="text/javascript">
            /*
                This creates the game on load, using this document as its source.
                It will automatically assign itself to `document.game`.
            */
            window.addEventListener("load", function () {new Game(document);}, false);
        </script>
        <script type="text/plain" class="init">

            >>  Area 0 is the splash screen (see below)

            loadArea (0)

        </script>
        <script type="text/plain" class="step">

            >>  Step code would go here

        </script>
        <script type="text/plain" class="click_function touch_function" data-click-number="1" data-touch-number="1">
            game.poke_active.set (true)
            game.poke_x.set (x)
            game.poke_y.set (y)
        </script>
        <script type="text/plain" class="click_function touch_function" data-click-number="2" data-touch-number="2">
            game.poke2_active.set (true)
        </script>
    </head>
    <body hidden style="display: none;">
        <h1>Jelli : A Game Engine</h1>
        <p>
            Any content you place in here remains hidden unless it is assigned the proper class for handling by the script.
            By editing this file, you can program your game.
        </p>
        <p>
            Be sure to keep the <code>hidden</code> attribute on the <code>&lt;body&gt;</code> element, and to load the jelli script in the <code>&lt;head&gt;</code>.
            <code>&lt;meta name="viewport" content="user-scalable=no,width=device-width"&gt;</code> is also helpful.
        </p>
        <section>
            <h2>Game setup</h2>
            <p>
                Certain attributes on the &lt;html&gt; element can be used to configure game settings.
                The <code>data-vars</code> attribute declares global JelliScript variables which can be accessed from any JelliScript code.
            </p>
            <p>
                Sometimes the game itself needs scripting which cannot be achieved at a lower level.
                This can be accomplished through two scripts, which should appear in the &lt;head&gt;.
                The first, of class <code>init</code>, specifies the initialization code, which is run during game setup.
                The second, of class <code>step</code>, specifies the code to run each time the game's logic is processed.
                These scripts should have type <code>text/plain</code> and be written in JelliScript.
            </p>
        </section>
        <section>
            <h2>GUI Elements</h2>
            <p>
                These elements are used to render the game system itself, rather than things within the game.
                They are not drawn to the canvas.
                The first <code>&lt;img&gt;</code> elements with the given classes will be chosen.
            </p>
            <section>
                <h3>The elements:</h3>
                <img class="gui-border" alt="Border" src="gui/cnvs-border.png"
                     data-sprite-width="8"
                     data-sprite-height="8"
                     data-system-background="#4f4f4f"
                     data-screen-background="#000000"
                     >
            </section>
        </section>
        <section>
            <h2>Screens</h2>
            <p>
                The <code>&lt;canvas&gt;</code> element creates a screen where the game is actually drawn.
                These elements should be listed in order, from back to front.
                The <code>id</code> of these elements <strong>must</strong> be specified (and unique)&mdash;this is used as an identifier within the game's script.
            </p>
            <p>
                The <code>data-type</code> attribute lets the game know how often the canvas should be cleared.
                <code>area</code> canvases are only cleared on area change, and are a good place to draw tiles.
                <code>animation</code> canvases, on the other hand, are cleared every frame, and are intended for animations.
                Canvases without this attribute must be cleared manually.
            </p>
            <section>
                <h3>The canvases:</h3>
                <canvas id="background" data-type="area" width="256" height="160">Map tiles go here.</canvas>
                <canvas id="mainground" data-type="animation" width="256" height="160">Characters and particles go here.</canvas>
                <canvas id="foreground" data-type="area" width="256" height="160">Structures go here.</canvas>
                <canvas id="textground" width="256" height="160">Dialogue and the like goes here.</canvas>
                <canvas id="menuground" width="256" height="160">HUDs and pause menus go here.</canvas>
            </section>
        </section>
        <section>
            <h2>Images</h2>
            <p>
                When you don't need sprite-based rendering but just want to paste a whole image to the canvas, elements with class <code>image</code> is how you do that.
                The <code>id</code> of these elements <strong>must</strong> be specified (and unique)&mdash;this is used as an identifier within the game's script.
            </p>
            <p>
                Images are screen-specific, and you can specify which screen you want to draw them to with the <code>data-screen</code> attribute.
            </p>
            <section>
                <h3>An image:</h3>
                <img id="ctrlimg" class="image" alt="This is just used as a sample, lol" src="gui/ctrl.png"
                     data-screen="menuground"
                     >
            </section>
        </section>
        <section>
            <h2>Sprite sheets</h2>
            <p>
                These elements contain the sprites used throughout the game.
                Their type is identified via their class: <code>letters</code> identifies an alphabet, <code>tileset</code> represents a tileset, and <code>sheet</code> represents any other spritesheet, such as one for use with characters.
                The <code>id</code> of these elements <strong>must</strong> be specified (and unique)&mdash;this is used as an identifier within the game's script.
            </p>
            <p>
                <code>tileset</code> sprite sheets <strong>must</strong> be provided with a <code>data-collisions</code> attribute, whose value is Base64-encoded binary collision data.
                This data should be a sequence of 4-bit bytes, one for each tile in the set, indicating which parts of the tile prevent objects from passing through.
                The least significant bit notes the top-left corner, the next the top-right, then the bottom-left, and the most significant bit indicates the bottom-right.
                Thus, a tile which has been assigned the bit <code>0x7</code> = <code>0111</code> (big endian) only allows objects through its bottom-right corner, while the bit <code>0x8</code> = <code>1000</code> permits the opposite.
            </p>
            <p>
                <code>letters</code> sprite sheets may optionally have any number of <code>data-palette-*</code> attributes assigned, these specify options for text colour.
            </p>
            <section>
                <h3>The letters:</h3>
                <img id="letters" class="letters" alt="Letters" src="letters/letters.png"
                     data-sprite-width="3"
                     data-sprite-height="5"
                     data-linefeed="&#x0A;"
                     data-palette-black="#0c0c0c"
                     data-palette-red="#e83f2c"
                     data-palette-sea="#31b9db"
                     >
            </section>
            <section>
                <h3>The tilesets:</h3>
                <img id="tiles" class="tileset" alt="Tiles" src="tilesets/tiles.png"
                     data-sprite-width="16"
                     data-sprite-height="16"
                     data-collisions="///APw=="
                     >
            </section>
            <section>
                <h3>Other sheets:</h3>
                <img id="characters" class="sheet" alt="Jelly" src="sheets/characters.png"
                     data-sprite-width="16"
                     data-sprite-height="16"
                     >
            </section>
        </section>
        <section>
            <h2>Sprites</h2>
            <p>
                Game characters are rendered using collections of sprites, which are given the class <code>sprites</code> and contain sprites of class <code>sprite</code>.
                The <code>id</code>s of sprite collections <strong>must</strong> be specified (and unique)&mdash;they are used as an identifier within the game's script.
                Additionally, the <code>data-sheet</code> attribute needs to be defined:
                It specifies which <code>sheet</code> to draw the sprites from.
            </p>
            <p>
                The <code>data-box-x</code>, <code>data-box-y</code>, <code>data-box-width</code>, and <code>data-box-height</code> attributes set the center and dimensions of the sprite bounding box (for collision checking).
                If not set, the box will fill the entire sprite.
            </p>
            <p>
                The sprites themselves take a couple of attributes:
                <code>title</code> names the sprite&mdash;these need to be unique within a given sprite collection but not necessarily across the document.
                It essentially functions by setting up a character variable with the value of the sprite's number, and you can always just use the number instead.
                <code>data-index</code> (required) specifies the starting index for the sprite, and <code>data-length</code> specifies the length of the animation (this defaults to 1).
            </p>
            <section>
                <h3>Sprite collections:</h3>
                <div id="jelly" class="sprites"
                     data-sheet="characters"
                     data-box-x="8"
                     data-box-y="8"
                     data-box-width="10"
                     data-box-height="10">
                    <span class="sprite"
                          title="lf"
                          data-index="0"
                          data-length="2"
                          ></span>
                    <span class="sprite"
                          title="rt"
                          data-index="2"
                          data-length="2"
                          ></span>
                </div>
            </section>
        </section>
        <section>
            <h2>Characters</h2>
            <p>
                Characters are used to insert any interactive element&mdash;including NPCs and player characters, but also potentially other elements, like doors&mdash;into the game.
                They have the class <code>character</code>, and should a couple of scripts.
                The <code>data-vars</code> attribute is used to declare character variables for use later in code; these are initialized to 0.
                The <code>data-sprites</code> attribute tells which sprite collection to use with the character.
                The <code>data-collides</code> attribute determines whether the sprite is involved in collisions; if present, it should have a value of either <code>map</code>, <code>character</code>, or <code>all</code>.
                An element without a <code>data-collides</code> attribute is not involved in any collisions, and if this attribute is present but no value is provided, it defaults to <code>all</code>.
            </p>
            <p>
                Characters generally need scripting.
                This is accomplished through two scripts, which should be placed inside the character.
                The first, of class <code>init</code>, specifies the initialization code, which is run when the area is loaded.
                The second, of class <code>step</code>, specifies the code to run each time the game's logic is processed.
                These scripts should have type <code>text/plain</code> and be written in JelliScript.
            </p>
            <p>
                Characters are destroyed when an area is unloaded, and the values of their variables are not stored.
            </p>
            <section>
                <h3>Some characters:</h3>
                <div id="pointer" class="character"
                     data-sprites="jelly"
                     data-screen="mainground"
                     data-vars="timer"
                     >
                </div>
                <div id="player" class="character"
                     data-sprites="jelly"
                     data-screen="mainground"
                     data-vars="timer tx ty tw th"
                     data-collides
                     >
                    <script type="text/plain" class="init">
                            x.set (16)
                            y.set (80)
                            dir.set (rt)
                    </script>
                    <script type="text/plain" class="step">

                            >>  This controls jelly movement:

                            (game.poke_active) ?
                                tx.set (game.poke_x)
                                tx.increment (area.x)
                                ty.set (game.poke_y)
                                ty.increment (area.y)
                                target (tx, ty)
                                th.set (height)
                                th.scale (.5)
                                tw.set (width)
                                tw.scale (.5)
                                tx.increment (-th)
                                ty.increment (-tw)
                                (tx < x) dir.set (lf)
                                (tx > x) dir.set (rt)
                            :
                                (game.key_up) ?
                                    (game.key_down) ?
                                        (game.key_left) ?
                                            (game.key_right) ?
                                                targetBy (0, 0)
                                            :
                                                targetBy (-1, 0)
                                            ;
                                        :
                                            (game.key_right) ?
                                                targetBy (1, 0)
                                            :
                                                targetBy (0, 0)
                                            ;
                                        ;
                                    :
                                        (game.key_left) ?
                                            (game.key_right) ?
                                                targetBy (0, -1)
                                            :
                                                targetBy (-1, -1)
                                            ;
                                        :
                                            (game.key_right) ?
                                                targetBy (1, -1)
                                            :
                                                targetBy (0, -1)
                                            ;
                                        ;
                                    ;
                                :
                                    (game.key_down) ?
                                        (game.key_left) ?
                                            (game.key_right) ?
                                                targetBy (0, 1)
                                            :
                                                targetBy (-1, 1)
                                            ;
                                        :
                                            (game.key_right) ?
                                                targetBy (1, 1)
                                            :
                                                targetBy (0, 1)
                                            ;
                                        ;
                                    :
                                        (game.key_left) ?
                                            (game.key_right) ?
                                                targetBy (0, 0)
                                            :
                                                targetBy (-1, 0)
                                            ;
                                        :
                                            (game.key_right) ?
                                                targetBy (1, 0)
                                            :
                                                targetBy (0, 0)
                                            ;
                                        ;
                                    ;
                                ;
                            ;

                            >>  This controls the direction the jelly is facing:

                            (game.key_left) ?
                                -(game.key_right) dir.set (lf)
                            :
                                (game.key_right) dir.set (rt)
                            ;

                            >>  This makes the jelly fall a little regardless:

                            targetBy (0, .1)

                            >>  This increments the timer if an arrow key is pressed:

                            (game.key_up)(game.key_down)(game.key_left)(game.key_right)(game.poke_active) ?
                                timer.mod_increment (15)
                                -(timer) frame.mod_increment (2)
                            ;

                            game.poke_active.set (false)

                    </script>
                </div>
            </section>
        </section>
        <section>
            <h2>Areas</h2>
            <p>
                Areas are used to generate a static background and/or foreground on which a section of the game takes place.
                Areas are given the class <code>area</code>, and should contain maps of the class <code>map</code>.
                Areas are referred to by index:
                The first area you define will have index 0, and the numbers will increase from there.
                (It makes sense to have area 0 be a splash screen).
            </p>
            <p>
                Maps tell the game how to render tiles on the screen.
                They are Base64-encoded strings, which should decode into 8-bit binary data.
                Each byte provides the index of the appropriate tile for that square in the map grid.
                The <code>data-tileset</code> attribute identifies the tileset from which to draw the tile, and the <code>data-mapwidth</code> attribute should tell how many tiles the map is wide.
                The <code>data-canvas</code> attribute should identify the canvas on which the map should be drawn.
            </p>
            <p>
                Characters can be loaded by referencing their <code>id</code>s in the <code>data-characters</code> attribute, or by passing a string to the <code>loadCharacters</code> function.
                This creates a new JelliScript object at <code>characters.character_id</code>.
                Characters can be deleted with the <code>characters.delete</code> function.
            </p>
            <section>
                <h3>Some areas:</h3>
                <div class="area" title="Splash screen"
                     data-vars="title_timer"
                     >
                    I have used this area to demonstrate programmatic character loading and managing.
                    <span class="map"
                          data-tileset="tiles"
                          data-mapwidth="16"
                          data-screen="background"
                          >AAEAAQABAAEAAQABAAEAAQIDAgMCAwIDAgMCAwIDAgMAAQABAAEAAQABAAEAAQABAgMCAwIDAgMCAwIDAgMCAwABAAEAAQABAAEAAQABAAECAwIDAgMCAwIDAgMCAwIDAAEAAQABAAEAAQABAAEAAQIDAgMCAwIDAgMCAwIDAgMAAQABAAEAAQABAAEAAQABAgMCAwIDAgMCAwIDAgMCAw==</span>
                    <script type="text/plain" class="init">
                        images.ctrlimg.load
                        images.ctrlimg.setPosition (80, 32)
                        characters.pointer.load
                        characters.pointer.x.set (88)
                        characters.pointer.y.set (120)
                        characters.pointer.dir.set (characters.pointer.lf)
                        game.texts.title.load ("textground", "letters", "Jelli Game Engine -- Demo")
                        game.texts.title.x.set (78)
                        game.texts.title.y.set (60)
                        game.texts.title.color.set ("sea")
                        game.texts.menu1.load ("textground", "letters", "Use arrow keys to move")
                        game.texts.menu1.x.set (96)
                        game.texts.menu1.y.set (120)
                        game.texts.menu1.color.set ("red")
                        game.texts.menu1.fill
                        game.texts.menu2.load ("textground", "letters", "Press X, touch, or click to begin")
                        game.texts.menu2.x.set (96)
                        game.texts.menu2.y.set (136)
                        game.texts.menu2.color.set ("black")
                        game.texts.menu2.fill
                    </script>
                    <script type="text/plain" class="step">
                        -(title_timer) game.texts.title.advance
                        title_timer.mod_increment (30)
                        (game.key_down) ?
                            characters.pointer.y.set (136)
                            game.texts.menu1.clear
                            game.texts.menu1.color.set ("black")
                            game.texts.menu1.fill
                            game.texts.menu2.clear
                            game.texts.menu2.color.set ("red")
                            game.texts.menu2.fill
                        ;
                        (game.key_up) ?
                            characters.pointer.y.set (120)
                            game.texts.menu1.clear
                            game.texts.menu1.color.set ("red")
                            game.texts.menu1.fill
                            game.texts.menu2.clear
                            game.texts.menu2.color.set ("black")
                            game.texts.menu2.fill
                        ;
                        (game.key_action)(game.poke_active) ?
                            -(game.poke2_active) ?
                                characters.pointer.dir.set (characters.pointer.rt)
                                game.texts.title.delete
                                game.texts.menu1.delete
                                game.texts.menu2.delete
                                game.clearScreen ("textground")
                                game.loadArea (1)
                            :
                                characters.pointer.dir.set (characters.pointer.lf)
                            ;
                        ;
                        (game.key_menu)(game.poke2_active) ?
                            images.ctrlimg.placed.set (true)
                        :
                            images.ctrlimg.placed.set (false)
                            game.clearScreen ("menuground")
                        ;
                        game.poke_active.set (false)
                        game.poke2_active.set (false)
                        characters.pointer.timer.mod_increment (10)
                        -(characters.pointer.timer) characters.pointer.frame.mod_increment (2)
                    </script>
                </div>
                <div class="area" title="The Sea"
                     data-characters="player"
                     data-vars="scroll_left scroll_right tx map0x map1x"
                     >
                    It is often way easier to define character code in their own init and step functions, however, as demonstrated here.
                    Then you can load the characters with the <code>data-characters</code> attribute.
                    <span class="map"
                          data-tileset="tiles"
                          data-mapwidth="16"
                          data-screen="background"
                          >BwcHBwcHBwcHBwcHBwcHBwYGBgYGBgYGBgYGBgYGBgYFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUBBQUFBQUFBQUFBQUFBQUFBAQEBAQEBAQEBAQEBAQEBA==</span>
                    <span class="map"
                          data-tileset="tiles"
                          data-mapwidth="16"
                          data-dx="256"
                          data-screen="background"
                          >BwcHBwcHBwcHBwcHBwcHBwYGBgYGBgYGBgYGBgYGBgYFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUBBQUFBQUFBQUFBQUFBQUFBAQEBAQEBAQEBAQEBAQEBA==</span>
                    <script type="text/plain" class="init">
                        map0x.set (0)
                        map1x.set (256)
                    </script>
                    <script type="text/plain" class="step">
                        tx.set (characters.player.x)
                        tx.increment (-x)
                        (tx < 8) scroll_left.set (1)
                        (tx > 248) scroll_right.set (1)
                        (scroll_left) x.increment (-1)
                        (scroll_right) x.increment (1)
                        (x < map0x) ?
                            map0x.increment (-256)
                            map1x.increment (-256)
                            setMapOffset (0, map0x)
                            setMapOffset (1, map1x)
                        ;
                        -(x < map1x) ?
                            map0x.increment (256)
                            map1x.increment (256)
                            setMapOffset (0, map0x)
                            setMapOffset (1, map1x)
                        ;
                        scroll_left.set (0)
                        scroll_right.set (0)
                    </script>
                </div>
            </section>
        </section>
    </body>
</html>
